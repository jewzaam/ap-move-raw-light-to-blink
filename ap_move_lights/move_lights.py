"""
Generated By: Cursor (Claude Sonnet 4.5)

This script moves LIGHT files from a source directory to a destination directory,
organizing them based on FITS header metadata into a multi-stage workflow.
"""

import argparse
import logging
from pathlib import Path
import re
from typing import Optional

import ap_common
from . import config

# Configure module logger
logger = logging.getLogger(__name__)


def move_files(
    source_dir: str,
    dest_dir: str,
    debug: bool = False,
    dryrun: bool = False,
    blink_dir: Optional[str] = None,
    accept_dir: Optional[str] = None,
    create_accept: bool = True,
) -> None:
    """
    Moves LIGHT files from source_dir to dest_dir, organizing them based on FITS header metadata.

    Args:
        source_dir: Source directory containing raw LIGHT files
        dest_dir: Destination directory for organized files
        debug: Enable debug output
        dryrun: Perform dry run without actually moving files
        blink_dir: Directory name for LIGHT files (default: "10_Blink")
        accept_dir: Directory name for accept subdirectories (default: "accept")
        create_accept: Whether to create accept subdirectories (default: True)

    Raises:
        ValueError: If source_dir does not exist or is not a directory
    """
    # Validate source directory exists
    source_path = Path(source_dir)
    if not source_path.exists():
        raise ValueError(f"Source directory does not exist: {source_dir}")
    if not source_path.is_dir():
        raise ValueError(f"Source path is not a directory: {source_dir}")

    input_pattern = config.INPUT_PATTERN_ALL

    # Use provided directory names or defaults from config
    blink_directory = blink_dir if blink_dir is not None else config.DIRECTORY_BLINK
    accept_directory = accept_dir if accept_dir is not None else config.DIRECTORY_ACCEPT

    # Required properties for LIGHT files
    required_properties = [
        "camera",
        "type",
        "date",
        "exposureseconds",
        "datetime",
        "filename",
        "optic",
        "focal_ratio",
        "filter",
        "targetname",
    ]

    # Get metadata for LIGHT files (recursive search, show status)
    data = ap_common.get_filtered_metadata(
        dirs=[source_dir],
        patterns=[input_pattern],
        recursive=True,
        required_properties=required_properties,
        filters={"type": "LIGHT"},
        debug=debug,
        profileFromPath=False,
        printStatus=True,
    )

    logger.info("Moving LIGHT files...")
    print("Moving LIGHT files..", end=".", flush=True)

    # Collect all "target" directories (parent of DATE) so can create "accept" sub-dirs
    target_dirs: set[str] = set()
    count_files = 0
    failed_files = 0

    for datum in data.values():
        filename_src = datum["filename"]

        if "type" not in datum:
            logger.warning("type not set in datum, skipping: %s", datum)
            print(f"WARNING: type not set in datum, skipping: {datum}")
            continue

        # Determine destination filename based on metadata (using BLINK directory)
        filename_dest = ap_common.normalize_filename(
            output_directory=dest_dir,
            input_filename=filename_src,
            headers=datum,
            statedir=blink_directory,
        )

        # Move the file with error handling
        try:
            ap_common.move_file(
                from_file=filename_src,
                to_file=filename_dest,
                debug=debug,
                dryrun=dryrun,
            )
            count_files += 1
        except OSError as e:
            failed_files += 1
            logger.error("Failed to move file %s: %s", filename_src, e)
            print(f"\nERROR: Failed to move {filename_src}: {e}")
            continue

        if count_files % config.PROGRESS_INTERVAL == 0:
            print(".", end="", flush=True)

        # Create accept directories for target directories
        if create_accept:
            for t in re.findall(config.TARGET_DIR_PATTERN, filename_dest):
                if t not in target_dirs and not dryrun:
                    # Create the accept directory as we go, more idempotent overall
                    try:
                        (Path(t) / accept_directory).mkdir(parents=True, exist_ok=True)
                    except OSError as e:
                        logger.error("Failed to create accept directory %s: %s", t, e)
                target_dirs.add(t)

    summary = f"\nMoved {count_files} LIGHT file(s)"
    if failed_files > 0:
        summary += f" ({failed_files} failed)"
    logger.info(summary.strip())
    print(summary)

    # Clean up empty directories in source
    logger.info("Cleaning up empty directories...")
    print("Cleaning up empty directories...")
    ap_common.delete_empty_directories(source_dir, dryrun=dryrun)


def main() -> None:
    """Main entry point for the command-line interface.

    Parses command-line arguments and invokes move_files with the provided options.
    Exits with code 1 if an error occurs during processing.
    """
    parser = argparse.ArgumentParser(
        description="Move LIGHT files from source directory to destination directory"
    )
    parser.add_argument(
        "source_dir", type=str, help="Source directory containing raw files"
    )
    parser.add_argument(
        "dest_dir", type=str, help="Destination directory for organized files"
    )
    parser.add_argument("--debug", action="store_true", help="Enable debug output")
    parser.add_argument(
        "--dryrun", action="store_true", help="Perform dry run without moving files"
    )
    parser.add_argument(
        "--blink-dir",
        type=str,
        default=None,
        help='Directory name for LIGHT files (default: "10_Blink")',
    )
    parser.add_argument(
        "--accept-dir",
        type=str,
        default=None,
        help='Directory name for accept subdirectories (default: "accept")',
    )
    parser.add_argument(
        "--no-accept",
        action="store_true",
        help="Do not create accept subdirectories",
    )

    args = parser.parse_args()

    # Configure logging based on debug flag
    log_level = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(
        level=log_level,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    try:
        move_files(
            source_dir=args.source_dir,
            dest_dir=args.dest_dir,
            debug=args.debug,
            dryrun=args.dryrun,
            blink_dir=args.blink_dir,
            accept_dir=args.accept_dir,
            create_accept=not args.no_accept,
        )
    except ValueError as e:
        logger.error(str(e))
        print(f"Error: {e}")
        raise SystemExit(1) from e


if __name__ == "__main__":
    main()
